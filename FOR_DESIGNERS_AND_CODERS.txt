SYNTAX: 

Naming Convention: explain what your variables do. if you use generics or templates, try not to use T/U/V - you can call these what you want, and non-programmers have no idea what T means
so a variable that counts the number of times you call function foo should be something like "int numTimesFooCalled". You can have fun with your names, but try not to list the entirety of 
eminem's Rap God in your function call (or something less hyperbolic, but still in that same vein)
if you didn't get the above reference: https://www.youtube.com/watch?v=c7_CcBgZ2e4

Capitalization:
--when you have multiple word variable names (see naming convention), try to follow these rules:
Variables should use camelCase. int count, otherCount;
Functions and Delegates should use TitleCase. I admit i sometimes fail at this, I learned to do camel case for everything but classes and it's a hard habit to break. 
Classes use TitleCase So: class Batman{ ...}
Enums use TitleCase. enum values use CAPITALS so enum Foo {BAR, BAZ, HELLO}
Constants and Public Readonly values use CAPITALS. again, see naming convention. ex: public const int NUM_DAYS_IN_WEEK = 7;

Brackets on new lines. We aren't monsters. It's easier to read. 
--Exception: anonymous functions, empty constructors or classes, and getters/setters. these can remain on one line if they are short.

Getter/Setter Symantics: if your setters or getters take multiple lines, they probably should be functions.

If/Else: one line if statements are okay, but not recommended. Brackets are still on new lines. 
If conditions are mutually exclusive, use "else if". Try to be clever with these if you feel comfortable doing so.
for example: 
if (height > 75) {}
else if (height > 65) {}
...
else if (height > 15){}
else{}
instead of 
if (height > 75){}
if (height > 65 && height <= 75)
...
if (height > 15 && height <= 25)
if (height <= 15){}

these function identically, but the first is cleaner, and actually faster - the compiler can optimize with it. if you need to, feel free to comment to yourself what the case does. so:
if (height > 75) {} //76+
else if (height > 65) {} //&& height <= 75 //66-75
...
else if (height > 15){} //&& height <=25 //16-25
else{} //15-

again, if you aren't comfortable with your skills at this, don't - we're not pompous assholes - program at your skill level. also, the gains are not significant, especially if you mess up and they cause errors!

Symantics:
C# allows properties to be set shorthand when using new. I understand the appeal, so if you use it comment how it works so people not as familiar with c# know what's going on.
it also allows properties to be set with => notation. i'm fond of it, as it makes them really short. but you might want to comment them anyway. 

DESIGN:

Separate Logic and Text Output:
Current Design is to have all your code in one location and all your text in another. this allows writers to do what they do best, and programmers to do the same.
For events or interractions, like visiting a place or talking to a character, all the text should be stored as multiple functions that return nothing and output the string
to OutputText. What we want from these functions is the most text per function call, with the least number of variables passed in. You can expect the writer to do small amounts of code, 
like check the gender passed in and print "him/her/it/other politically correct pronoun" accordingly, or get the descriptor of the various body parts, but they shouldn't be doing much logic.
small logic, like printing an "s" at the end if they have more than one, or printing a very specific string for an edge case is ok, however. if it's an entire wall of text because the pc is
a quadruped (quadroped? has 4 legs, like a horse or 'taur), and that alters the particular scene, make that its own function. it's a big design change from before, but it makes: 
-> translating easier - if we decide to support multiple languages - just change all the string functions and alles gut! viola! if we were smart, we could even add some sort of dynamic loading script
so people could provide a language pack as an XML document or something and it just was plug and play - and that's significantly easier if all the strings are in one location or one folder. 
-> debugging easier - the code is now all in one place and no text is in the way. suddenly, thousands of lines to debug becomes maybe 200. replace the string calls with debug related calls and we
suddenly can track errors much easier. (we also have new debug tools at our disposal - more on that later.)
-> spellchecking and grammar correcting easier - if you copy-paste code into a word-processing application, it's a jumbled mess. it's much easier to deal with when 90% of it is text, instead of 50%.

Design First, code later:
Our new design is much friendlier, but it's also not designed to just "wing it." if you design a species, great! how does the player go about transforming into it? what body parts does it have that are unique?
how do you describe these body parts? how would you describe it on some NPC? how about the player? what's the text that it displays when it reverts back to the human part?
what does it say when you transform into it - say, from a dragon part? an imp part? a harpy part? and so on.
Once you have all this, it's relatively straightforward: 

First, deal with the body parts. For each body part, you will need five functions - one describing the body part, one describing the part with flavor text when used to describe it on a creature,
one to describe it on the player when the player asks for their appearance, one to display when transforming into it, and one to display when reverting back to the default of that type. Note that you should always
take into account that someone may add another body part of that type after you, so if, for example, you have unique strings for each old body part you had before transforming into this one, make sure you have a 
default case. In that body part's string file, add your functions.

Then, you will need to actually create your body part. in that body part's type class, add, below all the others (generally in the format public static readonly Type NAME), add your own, matching that format.
pass in a reference to the functions you just defined in the strings file, and you're done.
Repeat this for all body parts.

Now, implement the item or means to transform into this race. If you can, provide a means for the game to call that transformation, even if the corresponding item wasn't used, or barring that, allow the game to
"use" the item silently, without mentioning the item itself in the transformation text. this way, we can possibly implement a wearable or NPC interraction in the future that causes the player to transform.
An example of this is the Naga Dress in the current ActionScript version of the game - you drink (nonexistant) snake oil every morning, instead of it just being some effect of the dress. 

Finally, add some means for the player to acquire this item. Either add this to the list of drops for an area, or through food at a restaurant. Done

------------------------------------------------------------------
NOTE: the Following only applies to objects. if you assign a local primitive (int, bool, etc) to the value is some class, changing that boolean won't affect the class. This is also how we can copy 
two objects so that changing one doesn't affect the other. You can also do anything you want with anything you want in your local scope, so long as you don't change anything out of your scope.
If it helps, think of elementary school recess: you can go outside to play, but if you want to go somewhere else, like inside to use the restroom, you have to ask a teacher. and you certainly can't leave.

-------------------------------------------------------------------

Memory Allocation:
This is a game that isn't resource intensive, but we do use a fair bit of memory storing all the strings. one downside to moving strings to static classes is they can be in memory 
more often than the old approach. Still, it's not really a major issue. That said, try not to use "new". Every body part so far is designed to be generated once during initialization
of the creature, then updated as needed - don't generate more of them. Generating a new Enemy for combat is fine, as we aren't in combat all the time, and we're only allocating one. 
additionally, once combat ends it's gone - it does not persist like your arm does, for example. obviously, you will have to use new internally when creating a body part, but limit it to there.

Assignment/New
Because we're not using "new", we won't be using assign (=) with these objects very often, if ever at all. changing the type of body part is a function call with the new body part type, as is changing its 
unique variables, like length, color, size, etc. do any assignments inside of a body part or instance, and make the main group call you. in the end, it's simpler for everyone - as you won't have writers 
trying to make code work, and developers wont have to worry about where a writer changed a value. for more, see below.

Mutability/Immutability:
We've designed the game with the idea that most data is Immutable - it does not change ever, and is shared by everything that needs it.
so, every demon-morph or demon or whatever that has "imp arms" has a reference to the IMP instance of the arms class. it'd be redundant to 
create a new arm type with the exact same values as every other imp out there, multiple times. 
However, you might be quick to point out that not every imp arm is the same - imp claws, for example, reflect their skin tone, which is unique to each imp.
The solution is to implement a two-part system: a mutable storage class that stores the type and any relevant variables that change, like size or color.
it stores a reference to the immutable type that defines it. to change types, like one might do after using a TF item, we call an update on the storage class


Side Effect:
A bit of context: C# stores objects by reference - so if you assign one instance of a class to another, it will not be a new object, just a reference to the other one. this is also known as a "shallow copy."
if you know how this works, skip below. otherwise, consider this simple example:
public class CustomNumber
{
	public int x;
	public CustomNumber(int value)
	{
		x = value;
	}
}
class Main
{
	//objects are passed by reference
	CustomNumber Foo;
	CustomNumber Bar;

	Foo = new CustomNumber(5); //create a new CustomNumber
	Bar = Foo; //pass a reference to the new custom number created above to bar.
	Console.WriteLine(Foo.x); //prints 5
	Console.WriteLine(Bar.x); //prints 5
	Foo.x = 1;
	Console.WriteLine(Bar.x); //prints 1
	Bar.x = 2;
	Console.WriteLine(Foo.x); //prints 2

	//but the same doesn't happen with primitives.
	int z,a;
	z = 1;
	a = z;
	Console.WriteLine(a); //prints 1
	Console.WriteLine(z); //prints 1
	z = 5 
	Console.WriteLine(a); //prints 1
	Console.WriteLine(z); //prints 5
}
when we update Foo's x value, then ask for the x value in bar, we see that it has changed in Bar. similarly, updating Bar also updates Foo. Now, we can fix this with a copy constructor.
Note that it doesn't happen with non-objects, like int,float,etc. Disclaimer: i'm not sure what happens with strings off the top of my head.

This is really useful because we can store the same reference multiple times so that each imp has the same ArmType - an imp's arm - without having to create new ones each time.
But, it leads to two problems: 
changing something that multiple instances of a class use, so now everyone has the same value, when they shouldn't (Mutating an immutable), and
assigning (using =) a mutable value to another mutable value. (mutable sharing)

The solution to both is really simple in theory: just don't do it. but if programming was that easy, we'd never have bugs, something anyone who has played this before can attest to not being the case.
so, here's how to fix these.

Problem: Mutating an Immutable.
Solution: Make your class truly immutable.

Luckily, this is relatively easy to do - prevent anything in an immutable class from being modified anywhere but that class. 
make all your variables properties and it so that anyone can read the value, but no one can change it. Or, if you know the value won't change outside the constructor, make it readonly.
Do not store anything unique to each instance of that class, like hair length or fur color or girth inside this class. that's what the container is for.
If you have something unique to your class, lets say number of horns, and you want to control how to grow them, have the container pass in the value and return the changed value.
or, pass the value in from the container by reference, and take advantage of the reference trick.

Problem: Mutable sharing:
Solution: Don't, unless the lifespan of that object or variable is insignificant.

the second is much more tricky, and the only solution i can offer is "don't do it." Most of the time, you won't really have anything else available to do this with, but perhaps you have the player and a demon
in the same room, and you want to make the player's genitals match the demon. if that demon stays in memory, and we change our genitals, the demon's junk will magically change as well. while that sounds cool,
it's probably not what we want. The "don't do it" approach will cover 99.9% of the time - if you think you need to, be REALLY sure. The only time i can see it being necessary is with the doppleganger battle, 
and your doppleganger will be removed from the game after you beat it, so it isn't an issue. if you do, make sure that object is not referenced anymore, so garbage collection takes care of it. this will happen
to the doppleganger immediately after you beat it (and do with it what you will).
--------------------------------------------------------------------------------------------------------

