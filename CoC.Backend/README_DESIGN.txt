This is a general readme for the project at large. it's not a readme for how to use or compile this, but instead explains how things work and why they're implemented as they are.

**************
"CLASS" ENUMS
**************
One important thing to note is that C# uses C/C++ style enums - essentially, an Enum is nothing more than a Constant (const) value, but with some metadata attached to it to allow for some enum-specific options, like a count, isDefined flag, and so on. it does not have any type-checking (you can use any value of the underlying integral type, even if it isn't defined), and you can't add things like members or functions to it. You do have the option to hack these in with extension methods, but there's no guarentee the extension method will have all the enum values when a new one is added, and removing an enum value will likely break that. Java, on the other hand, treats Enums like classes, which can be extended to require certain things be passed in during creation, which allows them to be much more useful. It is possible to simulate Java-style enums in C#, using an immutable class with a private constructor and static readonly members (which i call 'Class Enums'). I've attempted to get away with C# enums when i can, but more often then not you will see ClassEnums used instead. All Body Part Behaviors are ClassEnums, as are all Piercing/Tattoo Locations. Things like Vaginal Wetness/Looseness are kept as enums with extension methods. Generally speaking, if the type is simple and will not change much (if ever), it is left as a C# enum. If it is complex or is defined using inheritance or could have additional members or altered behavior in the future, it is written as a ClassEnum.

************
SEPARATION OF CONCERNS
****************
When viewing the code or trying to find errors, it's generally much easier to deal with the code in one spot, and the text in the other. There's a reason C/C++ still uses Header files, even though they aren't strictly speaking necessary - aside from making the compiler's job much easier, they are also much easier to debug. C# technically supports this, albeit in a very limited capacity - C# supports partial classes, which let your break up a class across multiple files. This is a bit of a double-edged sword - If you do so because your code is becoming unweildy, it's probably a sign of bad design and you should break your code into sub-classes, but if you do so to separate concerns, it can be incredibly helpful. (Unfortunately, i'm guilty of the former with the Genitals class, but it's just so useful to have all of that together. i dunno.) The overall goal for this project is to do the latter wherever possible - if we can provide a single location for all the text in a given behavior, we can simply let our writers proof-read that text page, and do as little actual code as possible to display the text. Similarly, if we can keep all the text out of the rest of our code, it allows programmers the ability to debug the code without having to scroll through hundreds of lines of text. This does mean our projects have more files in them, but it should be easier to maintain. Additionally, when the code compiles, all the partial parts of a class are put together, so the program doesn't know we made our lives easier, and there's no additional cost when running the program.
One other nice result from this is it allows us to potentially support multiple languages. I'm not going to lie, this will likely never happen, but it is possible to simply swap out the text files with another language and recompile, and everything will just work. It's theoretically possible to load files from the hard drive and dynamically change the language during gameplay, but this will require some careful planning and coordination, and i don't think it will happen. But, you never know!

****************
FRONTEND, BACKEND, GUI
****************
The code is broken into 3 projects: Backend, Frontend, and GUI. The goal behind this design is that the code is modular - if we want to port the project to a new platform (like iOS or Linux, which are currently not supported in Vanilla), we can simply create a new GUI project targeting these platforms and leave the frontend and backend code unaltered. This means if you want to pretty up the GUI, you don't need to worry about what's going on in the backend, and if you want to implement new content, you can be sure the GUI layer will still work, even if you've added new creature sprites or credit text or something. It's even possible to create an entirely new game simply by creating entirely new content in the frontend. OR, if you really wanted, you could demake this game into a terminal-style game (a la Colossal Cave Adventure. No, I'm not that old, AMC's Halt and Catch Fire referenced it.)

A quick disclaimer, though: While the backend content is designed to be as flexible as possible, there may be edge cases or additional basic tools not supported natively in the backend. You may need to add things there, but for the most part, you simply can define content that simply calls the right functions in the backend and everything just works automatically.
One major downside to this approach is that it is difficult to alter the GUI to support new things - unless you update every GUI port out there, adding things like pop-up achievements (which, thankfully, were added before this project was finished or else we wouldn't have them) or whatever becomes more and more difficult the later on it is done. It can still be done, of course, but you'll need to update all versions of the GUI.

Now, you might be wondering WHY X is in the Backend. First off, a lot of abstract classes exist in the backend so the backend can use them without them being fully defined or implemented. then, you can implement them in the frontend and make them do whatever you need.
If you are asking why a class is not abstract (or perhaps sealed, so it cannot be derived), and is defined in the backend, congratulations - you're smart enough to understand what the code is doing and are raising (probably) valid points about the design. The overall goal was to put as many core systems in the backend as possible, but a secondary goal was to make the code as easy as possible to deal with if you were just creating content, and as hard as possible to break. In programming terms, i've obfuscated the important code. Some things i decided were too important to leave up to the average joe to handle, because they can become messy quickly if done improperly, and frankly i'm not sure i've done the best job of handling them myself. The creature and all the related body parts, for example, are all implemented in the backend, and cannot be created from the frontend without using the provided options. This is primarily done because they use the ClassEnum paradigm (defined above), and i felt that was too much to keep in the frontend. You'll notice some things are implemented in the frontend, then passed back to the backend as lists during initialization (for example, a list of difficulties) as a workaround for classes that act like ClassEnums, but aren't. I am not fond of doing this, and doing it with the creature body parts would get out of hand quickly. This, unfortunately, creates a side-effect when you want to store additional information about the player in the player class, but the player class needs to exist in the backend as well. The solution was an abstract class in the backend, which was implemented in the frontend. It's recommended you use the derived class wherever possible in the frontend, to make your lives easier. there's also an interface (because classes can't inherit more than one thing) that can be applied to creature classes in the frontend that extends their behavior significantly.
Tl;Dr: To make the backend work better, and prevent people from accidently breaking things. If you know what you're doing, you can probably figure out the tools i've added to extend the creature and stuff defined in the backend

**************
SERIALIZATION (AKA SAVING)
**************
The old code had a very large, allocated block of code for all the various variables, and flash lets us dynamically define various blocks of it as we see fit. C# does not let us do that. But, fear not, we have a better option (well, sort of). A few save data classes are defined in the frontend, backend, and GUI layers - anything public in them that can be read and written to (so, not readonly properties/getters or write only setters) will automatically be written to a file when we save. Unlike the previous version, we don't need to store a large array of objects and parse them dynamically; we can just declare variables in here and during runtime, we'll make as big a block of memory as we need to keep all this data. no more kGameClass[VARIABLE_NAME_CONST]. just say public int foo or public byte timesIveDied... Well, mostly. There are some important things to consider when doing this.

Keep things limited to primitives, simple collections of primitives, or simple structs. some C# classes are serializable by default (BitArray, for example), but not all of them serialize nicely. Use things like int, float, bool, byte, ushort, etc. You can also use things defined in the backend (Piercing Jewelry, Tattoos, Body Part Types, Body Parts, Creatures, anything defined in Utils.cs), as these are also safely serialized. more on how these are serialized below.
DO NOT REMOVE ANYTHING FROM THESE SAVE FILES!!! Panicking yet? Okay, that's a bit of an overreaction. It's actually possible to alter how these save data classes save and load, but it's not recommended. We use what's generally considered 'magic' (or, probably more likely, 'black magic') in programming to do our saves. In other words, we do things that aren't easily understood, but just work somehow. To demistefy how these work, exactly, you have to dive into how we do saves.

We've written our own serializer/deserializer (save/loader), because the built-in ones aren't designed to allow you to add or remove things willy-nilly. officially, ours doesn't like it if you do, but will work just the same. We do this for all the body parts (which are saved using the read-only data class version of them), and in turn the creature (which uses all these body parts), as well as the saver classes.
First a bit of context: Our deserializer has 3 phases: an initialize phase, a convert phase, and a finalize phase. During the initialization phase, we determine which class we are attempting to read, then INITIALIZE it WITH A CONSTRUCTOR. This is important! This is different from many deserializers, and lets us deal with missing data. This means that any initial values defined are automatically used, instead of the default for that data type. if the serializer is missing some data during the convert phase, it will not break; it will simply leave the initial value unchanged and move on. This is what's known as a non-breaking change. A non-breaking change is a change to what we are expected to save and read, but if an old save does not have it, we can still use it as it. Generally, a non-breaking change is both forward and backward compatible - a new version of the game simply sets any missing variables to their defaults, and any previous versions of the game simply ignore the extra values. The next step is to actually parse the data and load it into the object in memory. If we are reading a legacy save, it will first convert all legacy data into data the current format expects. More on this later. finally, when this is done, you have the ability to validate and correct any data that is either wrong due to save editing or update variables using legacy values that haven't (yet) been versioned and removed. Again, more on this later. If you do not feel comfortable editing the save versions (which is perfectly understandable), you can simply leave any old values that have been replaced with modern ones, and simply ignore them in all future code. it's recommended if you do this to mark these values as obsolete or legacy with comments. Future people may bundle all of these values together and write a large version update to the save file that removes these unused values and handles old saves that still use them.

Versioning:
When data becomes obsolete and is replaced with better data, we don't generally want people to use it, so we should remove it. but we can't just remove it because old saves use it and we won't be able to parse the old data correctly if it's not there. This is what's known as a 'breaking change.' A breaking change occurs when we remove a value from our save that helps determine the correct data for this object, even if it's only used in obsolete saves, OR, even worse, we alter the underlying source for a value so that the value in an old save does not mean the same thing as the same value in a new save. For example, lets say we have an enum Direction {NORTH, SOUTH, EAST, WEST}; if we tell it to save using the underlying type, NORTH is 0, SOUTH is 1, EAST is 2, WEST is 3. If you reorder the enum, lets say to clockwise so its enum Direction {NORTH, WEST, SOUTH, EAST}; then WEST is now 1, SOUTH is 2, EAST is 3. when trying to read from an old save, which stored the direction using the original values, what was once WEST will now be EAST, and that's not right. A more useful example would be removing and renumbering some body parts - if you just shift the list over 1, the old values will be off by 1 and be the wrong type.
We solve this by providing a way to 'version' the code. Lets say, in that above Direction example, you HAVE TO reorder it. in this case, that doesn't make sense, but let's just pretend it does. we need to increment the version of our save file, because the old save version is no longer correct. however, we need to provide a 'converter' that has this current version number so that old save data expecting this version can be read, then converted to the new format. You'll notice every save data class has a ToCurrentSave function, and it usually returns 'this'. That's because we always save using the most current save version. Our converter classes do not return 'this'. Generally speaking, each converter class converts itself to the next save version, which then converts itself to the next save version (if applicable) until it's the current save version. Each converter class is responsible for taking the old, bad data and converting it to the correct data at the time of writing. You generally don't need to worry about the previous save versions, because they will trickle up to the current converter and work fine.

How to do it: Copy the current Version number from the saver class. create a new file, implementing the same saver data as the saver class does. set this new class's version number to the value you copied from the saver class. increment the saver class's version number by 1. implement the toCurrentSave function so that it correctly parses the data and returns something the saver class can handle correctly.

Generally speaking, you'll never have to deal with this. If you're certain a value is obsolete but dont want to mess with version, mark it as 'DontSave', make a note of why its obsolete, and then handle any time an old save sets this value during the finalize phase by converting it to the relevant, modern data (if applicable). when marked with 'DontSave,' all future saves will not write this value, so you can be sure only legacy saves will use it. Generally, we should have someone who is comfortable doing this scrub all obsolete values every 6 months or so and make a new save converter, and go from there.

***************
Systems
***************
All the systems for time passing, location changing, dungeoneering, etc are all handled in the backend. They are very powerful, and more accessible than Vanilla. let them handle things for you - that's their job. Events are now more clearly defined - when you tell the time engine to do its thing, it will go through all the hours you've told it to, proccing whatever happens along the way. If multiple events happen at once, the engine will handle it in a well-defined, consistent way. Each event is treated like a minature scene, so it's possible to stack events - if an event causes you to change locations and use up additional time, for example, this is perfectly ok, and doesn't require any hacks (afaik the only time this occured in vanilla was with Urta pregnancies, but idk). There is one major issue with the system - reactions are susceptible to issues when serializing. follow the directions for these and you should be fine.

******************
Transformations
******************
If you'll notice, TF items are super funky - they implement a transformation class. Why? because we're cheating a bit. It's possible for other things to cause these tfs, and we want to be able to reuse the code without having to have to send all our output to a dummy page, then checking to see what changed in our class. It's easier to just have a transformation class, and have the item implement it, then if we want another thing to also cause that tf, we can provide unique text and get to it.

*******************
Button List Maker
*******************
Because everything is designed to be plug-and-play, it's possible to create something that has more options than we have slots for. To work around this, a Button List Maker helper class exists. it will store all the potential buttons, and if there are more than we can display, will automatically create a next page and previous page-style list.