Quick note: In theory, we should only store information in the backend if it's truly integral to the backend items and how they are handled internally. I can't say that's completely the case everywhere, but it's still something to strive for. As such, the various wearable perks (slutty seduction, wizard's endurance, bulge armor) are not stored in the backend - what happens when we want something that previously only applied to armor also apply to lower garments? do we move it to wearables? and so on. Generally, updating these values means a lot of refactoring code, and we really should refactor the backend as little as possible. we could create an abstract class that derives armor or whatever and extend it with new values, but then it would only apply to armors - what happens when we want to apply it to other wearables? that's redundant code (which, again, makes maintenance more difficult). There are two different ways to deal with this: give it an interface that retrieves a class storing extra data (which we do with creatures), or create an interface for each different perk and apply them as needed. i chose the second, because we only have a few wearable-related perks and it's really straightforward to implement an interface. with the class method, if we add new variables to the class later, we might forget to update the default values. with interfaces, if you're missing one, it obviously can't affect you. either works, i suppose, but this is what we're going with.

Tl;Dr: to make code easier to maintain, the backend is to remain elegant, which means any perk related bools or whatever must be stored in the instances created in the frontend. it's possible to do this in a myriad of ways, but for perks that are common across several items, we've chosen to implement them as interfaces that can be implemented if a particular wearable supports that perk. for perks unique to a single wearable, or more complicated situations, you should roll out your own code and class as needed.

currently we do this for bulge armor, blood mage, and wizard's endurance perks, though more are likely to pop up as the code gets refactored.

We also do this for unique interactions that are common (or could be common) across various armor types. The goal is to remove hard-coded checks against certain armors so that the code will be future-proof if we add items that are similar later on. This does not apply to all instances, though - if an interaction is unique to that armor and couldn't possibly affect any other armor in the future, a hard-coded check is perfectly fine. Valeria Armor, for example, has some unique scenes involving the gooey companion that nothing else could possibly cause, so hard-coding a '.armor is GooArmor' is perfectly reasonable.

one such example is a swimwear interface. this has been added so any scenes revolving around swimming can simply check to see if whatever you're wearing counts as swimwear.

an aside: one exception to this rule is a 'mostly naked' flag - some enemy attacks will cause the enemy's lust to be raised if the player's armor is virtually non-existent or they aren't wearing any armor. unfortunately, this means we need that flag in the backend, because we need to handle a lot of attack based data there, and we replace nulls with 'Nothing' (to prevent null reference errors in case someone forgets to check if the creature actually has armor) in the backend, and obviously wearing nothing means the creature is naked and that flag should be true. On the plus side, these checks are now much easier to update to accept more armor - just set the armor's nearly naked flag to true. Previously, these checks only found bondage straps or nothing; now it will also find the various bikinis, among others.