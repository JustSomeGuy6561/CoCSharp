One of the things i'm trying to address is that some transformations could be caused by non-items, but the item was hard-coded into the text. The only way to proc it was therefore to just take it, even if that made no sense. So, i'm separating these out into transformations and consumables. it also has the nice effect of making the code really short in all the consumables, while all the grunt work is done here. it also lets the common behaviors (namely, oviposition) be defined in one spot that makes sense, and we don't need to hardcode in type checks. 

The only downside (and it's a major downside) is that each transformation needs to have a return value that explains what it just did, or be abstract and require an implementation for anything that can proc it. I chose the former, because that seems easier to handle. Basically, each TF also defines a TF results class, which is more or less a series of booleans that clearly states what it just did. for example, if a TF item can cause the player's wings to change, its result class has a bool, wingsChanged. when done, the result class is returned on the tf. Then, anything that uses it can decide how exactly it wants to display that information to the user. transformations could have default generic text based on what it did, but that's up to the implementer.

One issue this has is that it means some transformations that vary by source (like as a purified/pro/standard item variation) require additional code. Fortunately, transformations are not statically stored anywhere (though they can be within a transformation item if you really want) so you can give each a custom constructor as needed to handle things like this, and simply declare the transformation on-demand. This does mean you can't cache it (unless you know what you're doing and call something to update the internal values), which you don't get the caching gains, but you also don't incur the memory penalty of caching. if that means nothing to you, just ignore it. 

If you're worried about memory costs (don't be) or want to be fancy (aka, me), C# has a BitArray class, which essentially is an array of booleans, but with a much smaller footprint. store that privately, then give it some properties to expose the various boolean values so the average joe doesn't have to worry about bit indices. 