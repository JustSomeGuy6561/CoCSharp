One of the things i'm trying to address is that some transformations could be caused by non-items, but the item was hard-coded into the text. The only way to proc it was therefore to just take it, even if that made no sense. So, i'm separating these out into transformations and consumables. it also has the nice effect of making the code really short in all the consumables, while all the grunt work is done here. it also lets the common behaviors (namely, oviposition) be defined in one spot that makes sense, and we don't need to hardcode in type checks.

The only downside (and it's a major downside) is that each transformation needs to have a return value that explains what it just did, or be abstract and require an implementation for anything that can proc it. I originally went with the former, but realized it was a pain in the ass, and i'm gonna have to parse all the stuff anyway, so i might as well just make a class of it and call it a day. The downside is you lose the ability to display it in an order of your choosing, but it seems worth it in the end.

One issue this has is that it means some transformations that vary by source (like as a purified/pro/standard item variation) require additional code. Fortunately, transformations are not statically stored anywhere (though they can be within a transformation item if you really want) so you can give each a custom constructor as needed to handle things like this, and simply declare the transformation on-demand. This does mean you can't cache it (unless you know what you're doing and call something to update the internal values), which you don't get the caching gains, but you also don't incur the memory penalty of caching. if that means nothing to you, just ignore it.

If you're worried about memory costs (don't be) or want to be fancy (aka, me), C# has a BitArray class, which essentially is an array of booleans, but with a much smaller footprint. store that privately, then give it some properties to expose the various boolean values so the average joe doesn't have to worry about bit indices.

Also, don't be afraid to code it the "wrong way" - i.e. as an item with hard-coded changes and text, then convert it after. The same applies to adding a new tf source with an existing tf or item, though in those cases it may be easier to just copy-paste and modify to work with new tf. I've found that it can be a bit uncomfortable doing it the results way unless you have something to work off of, though if you design it out ahead, that problem goes away.

Additionally, if you can provide generic text for the various transformation effects, feel free to do so; it's really helpful, but not required.