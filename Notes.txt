This is a strong-typed, event-based, object-oriented revision of CoC. This does mean we lose dynamic typing tricks, but at the cost of developer sanity and ease of debugging. 
despite the jump to C# and more heavy emphasis on Object-Oriented patterns, we aren't losing the event-based functional programming of the original flash version. C# is flexible enough
to allow this without being overly complicated. a quick caveat - we do use delegates, which are typed callbacks, as well as action and func, which are typed, but anonymous, callbacks.

Design Philosophy: Generally speaking, I use "SICkLE" as my guideline (SImple, CLean, and Elegant), though this is generally up to your best judgement. However, in this scope, keep the following in mind:

All code should be self-contained. This means that all functions relating to a certain body part or NPC or whatever should be stored within that class or series of classes, not wherever it's referenced.
it's much easier, for example, to make a new type of arm if you can do it all in one place, and not have to worry about adding it to the player appearance function, or the arms description function, etc. 

Never hard-code a check. Remember, if your event or whatever needs to know what's going on, it's entirely possible that someone else wants to do the same thing. provide a clean method for allowing the system
to take care of these, like a queue or list, or even an event system (which is really a glorified list)

Be PASSIVE and LAZY: only do things when you need to. if we can determine the color of the player's arms from the body, we don't need to store the color in the arms, as that's redundant. further, we don't need to 
be notified every time the body changes color because we don't always need to know the arms' color. the only time we need the arms' color is if we're telling the user what the color of their arms is. Then, and only
then, should we ask the body what its color is.
This is especially important when taken with the no hard-code rule. Instead of hard-coding in a check to see if you need to run a special event EVERY TIME you enter camp, for example,
simply notify the camp ONCE whenever the event procs. 

Only keep what is necessary in memory. The game is probably small enough that this is irrelevant, but a smaller footprint is always nice, especially on potatoes. the old game kept everything in memory - every NPC,
every location, every scene was always active, even if not even remotely active, and even if they were disabled. we have a save state for this, and we also have static properties which allow us to access relevant
data even if the class is not active. Take advantage of what C# offers. 

In game terms, theres a check to see if Akbal granted a post-submission perk every time you go back to camp. But that's a bit too active, and actually needlessly adds an additional perk.
Instead, let the game passively take care of it - when the conditions arise to grant that perk (you submit to Akbal and RNG rolls favorably), simply notify the camp that it has a special event to proc.

Treat changes in state as events (but only if necessary). instead of constantly checking if something happened, have it tell us when it changed. For example, exgartuan grants a perk if you're wearing armor. instead
of checking if you're wearing armor, notify exgartuan when you have removed or equipped armor. Taking it one step further, you could provide a list for things to "subscribe" to that need to know the armor state,
like a perk that procs only if you're naked. when it changes, you notify all of them and they can react accordingly.

Use static properties to hide references to the save state. I'll provide an example later. the short version is that perks and status effects were used instead of properly adding things to the save state
(kGameClass) because it was easier to write and understand. unfortunately, kGameClass is still here, renamed and broken up into session and global save options. Fortunately, there's a way to hide all that 
gobbledygook by giving a class a static property that gets that save state value and sets also possibly sets it, and with the added benefit in that you can run data validation before updating the save data.
this also goes along with the self-contained idea presented above. give whatever class the variable refers to (so if it's about Jojo, for example, put it in the Jojo class) a static property, with the get 
part returning the value in the save state, and optionally providing the means to set that save state value via the set part. additionally, you can run data validation during the set part, like preventing a percent
stored as a byte (0-255), from being over 100. 

Assume the caller knows what he's doing. It's not the job of a callback to make sure it's being called correctly. If a dev calls the callback for player creation from anywhere outside of player creation,
the game will continue as if a new player was being created (and if data isn't properly set up for this, it'll break). if the game is super borked because someone messed up a callback, that's on them. 
In the event this happens to you make sure your callbacks are correct and you didnt, for example, accidently set the yes button to the no callback (minorly infuriating, by the way).